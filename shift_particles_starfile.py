#!/nfs/home/bbasanta/anaconda2/envs/py37/bin/python

import numpy as np
import json
from scipy.spatial.transform import Rotation as R
import pandas as pd
import argparse
import sys

def interpret(s):
    try: return json.loads(s)
    except ValueError: return s

def read_star(fname):
    version_n = 0
    opticgr_cols = []
    opticgr_entries = []
    part_cols = []
    part_entries = []
    rln_31 = False
    with open(fname, 'r') as file:
        lines = [i[:-1] for i in file.readlines()]
        loop_ = False
        for line in lines:
            split_line = line.split()
            if version_n == 0 and line.startswith('data_'): print('RELION version < 3.1 star file detected.'); version_n = 2;
            if line.startswith('# version'):
                print('RELION version >= 3.1 star file detected.')
                rln_31 = True
                version_n+=1
                loop_ = False
            if line.startswith('loop_'): loop_ = True; continue
            if version_n == 1 and len(split_line)>0:
                if line.startswith('_rln'): opticgr_cols.append(split_line[0])
                elif loop_: opticgr_entries.append(split_line)
            if version_n == 2 and len(split_line)>0:
                if line.startswith('_rln'): part_cols.append(split_line[0])
                elif loop_: part_entries.append(split_line)
    opt_dict = { i[0]:{ j:interpret( k ) for j,k in zip(opticgr_cols,i) } for i in opticgr_entries}
    opt_gr_df = pd.DataFrame.from_dict(opt_dict,orient='index',columns=opticgr_cols)
    part_dict = { n:{ j:interpret( k ) for j,k in zip(part_cols,i) } for n,i in enumerate(part_entries)}
    part_df = pd.DataFrame.from_dict(part_dict,orient='index',columns=part_cols)
    print('Read %d particle entries from RELION star file.'%(len(part_df.index)))
    return opt_gr_df,part_df,rln_31

def write_star(fname,opt_df,par_df,is_rln_31):
    fout = open(fname,'w')
    if is_rln_31:
        fout.write('\n# version 30001\n\ndata_optics\n\nloop_\n')
        #fout.write('_rlnOpticsGroupName #1\n')
        for n,col in enumerate(opt_df.columns):
            #fout.write('_rlnOpticsGroupName #1\n')
            fout.write('%s #%d\n'%(col,n+1))
        fout.write(opt_df.to_string(header=False,index=False,index_names=False)+'\n')
        fout.write('\n\n# version 30001\n\ndata_particles\n\nloop_\n')
    else: fout.write('\ndata_\n\nloop_\n')
    for n,col in enumerate(par_df.columns):
        fout.write('%s #%d\n'%(col,n+1))
    if not is_rln_31: fout.write('\n')
    fout.write(par_df.to_string(header=False,index=False,index_names=False)+'\n')
    fout.close()

def get_eulers_and_translation(mtx,angpix):
    rot, tilt, psi = R.from_matrix(mtx[:3,:3]).as_euler('ZYZ',degrees=True)
    x, y, z = tuple(mtx[:3,-1]*angpix)
    return [ rot, tilt, psi, x, y, z ]


if __name__ == "__main__":
    argparser = argparse.ArgumentParser(description='Use transformation matrices generated by chim_session_to_mtx.py \
                                                     to populate a template relion star file Euler angles and rotation origins.')
    argparser.add_argument('--template_star',required=True, type=str,help='RELION *.star file to use as template.')
    argparser.add_argument('--angpix',required=False, type=float ,help='Particle pixel size.')
    argparser.add_argument('--translation',required=True, type=str, help='Desired translation in pixels: X,Y,Z')
    argparser.add_argument('--particle_box_size',required=True, type=str, help='Particle box size in pixels: X,Y,Z')
    argparser.add_argument('--output_name',type=str,help='Name for output *.star file')
    args = argparser.parse_args()

    opt_df, par_df, is_rln_31 = read_star(args.template_star)
    translation = np.array([ float(i) for i in args.translation.split(',') ])
    angpix = 1.0
    if is_rln_31: angpix = args.angpix; translation = translation*angpix
    translation = tuple( translation )
    box_size = np.array( [ int(i) for i in args.particle_box_size.split(',') ] )
    in_angs = False
    if ('_rlnOriginXAngst' in par_df.columns) or is_rln_31:
        in_angs = True
        print('rlnOriginXAngst detected in star file particle records, translation will be provided in Angstroms.')
        if not args.angpix:
            sys.exit('Origin is required to be in Angstroms, but particle pixel size was not provided. Exiting without producing new star file.')
    
    container = []
    for idx in par_df.index:
        rot = par_df.loc[idx]['_rlnAngleRot']
        tilt = par_df.loc[idx]['_rlnAngleTilt']
        psi = par_df.loc[idx]['_rlnAnglePsi']
        eulers_mtx = R.from_euler('ZYZ',np.array([rot,tilt,psi]),degrees=True).as_matrix()
        ox,oy,oz = (0,0,0)
        if is_rln_31: ox,oy,oz = (par_df.loc[idx]['_rlnOriginXAngst'],par_df.loc[idx]['_rlnOriginYAngst'],par_df.loc[idx]['_rlnOriginZAngst'])
        else: ox,oy,oz = (par_df.loc[idx]['_rlnOriginX'],par_df.loc[idx]['_rlnOriginY'],par_df.loc[idx]['_rlnOriginZ'])
        if is_rln_31: box_size = box_size*angpix
        inx,iny,inz =  translation
        x,y,z = tuple(np.dot(np.transpose(eulers_mtx),np.array([inx,iny,inz])))
        if abs(ox+x)>box_size[0] or abs(oy+y)>box_size[1] or abs(oz+z)>box_size[2] : sys.exit('Particle %s is now outside the box, remove this entry from the input start file and start over.'%(par_df.loc[idx]['_rlnImageName']))
        container.append( [ ox+x*angpix, oy+y*angpix, oz+z*angpix ] )
    
    container = np.array(container)
    if in_angs:
        par_df = par_df.assign(_rlnOriginXAngst=container[:,0])
        par_df = par_df.assign(_rlnOriginYAngst=container[:,1])
        par_df = par_df.assign(_rlnOriginZAngst=container[:,2])
    else:
        par_df = par_df.assign(_rlnOriginX=container[:,0])
        par_df = par_df.assign(_rlnOriginY=container[:,1])
        par_df = par_df.assign(_rlnOriginZ=container[:,2])
    outname = '.'.join(args.template_star.split('/')[-1].split('.')[:-1])+'.shifted.star'
    if args.output_name: outname = args.output_name
    write_star(outname,opt_df,par_df,is_rln_31)

